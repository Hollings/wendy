<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wendy's Brain</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            background: #0a0a0a;
            color: #e0e0e0;
            font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.5;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        /* Auth Screen */
        .auth-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        .auth-screen h1 { font-size: 24px; font-weight: normal; margin-bottom: 8px; }
        .auth-screen p { color: #666; margin-bottom: 24px; }
        .auth-form { display: flex; gap: 8px; }
        .auth-form input {
            background: #111; border: 1px solid #333; border-radius: 6px;
            color: #fff; font-family: inherit; font-size: 14px;
            padding: 10px 14px; width: 200px;
        }
        .auth-form input:focus { outline: none; border-color: #555; }
        .auth-form button {
            background: #222; border: 1px solid #333; border-radius: 6px;
            color: #fff; cursor: pointer; font-family: inherit;
            font-size: 14px; padding: 10px 20px;
        }
        .auth-form button:hover { background: #333; }
        .auth-error { color: #f87171; margin-top: 12px; font-size: 13px; }

        /* Feed Screen */
        .feed-screen { display: none; }
        .feed-screen.active { display: flex; flex-direction: column; height: 100vh; }

        /* Main Layout - Two Column Desktop */
        .main-layout {
            display: flex;
            flex: 1;
            min-height: 0;
            gap: 0;
        }

        /* Main Column - Feed/Avatar toggle */
        .main-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            height: 100%;
        }

        /* Main column toggle bar */
        .main-toggle-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 20px;
            background: #0a0a0a;
            border-bottom: 1px solid #222;
        }
        .main-toggle-btn {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            color: #888;
            cursor: pointer;
            font-family: inherit;
            font-size: 13px;
            padding: 8px 16px;
            transition: all 0.15s;
        }
        .main-toggle-btn:hover {
            background: #222;
            color: #ccc;
        }
        .main-toggle-btn.active {
            background: #2a2a2a;
            color: #fff;
            border-color: #4ade80;
        }

        /* Feed view */
        .feed-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            overflow-y: auto;
            padding: 20px 40px;
        }
        .feed-view.hidden { display: none; }
        .feed-view > * {
            max-width: 1000px;
            width: 100%;
        }

        /* Avatar view */
        .avatar-view {
            flex: 1;
            display: none;
            align-items: center;
            justify-content: center;
            background: #050508;
            padding: 20px;
        }
        .avatar-view.active {
            display: flex;
        }
        .avatar-view iframe {
            width: 100%;
            height: 100%;
            max-width: 1024px;
            max-height: 1024px;
            aspect-ratio: 1;
            border: none;
            border-radius: 8px;
        }

        /* Right Column - Tabbed Sidebar */
        .sidebar-column {
            width: 350px;
            min-width: 350px;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: #0d0d0d;
            border-left: 1px solid #222;
        }

        /* Tab Bar */
        .tab-bar {
            display: flex;
            border-bottom: 1px solid #222;
            background: #0a0a0a;
        }
        .tab-btn {
            flex: 1;
            padding: 12px 8px;
            background: none;
            border: none;
            color: #666;
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
            border-bottom: 2px solid transparent;
        }
        .tab-btn:hover { color: #aaa; background: #111; }
        .tab-btn.active {
            color: #fff;
            border-bottom-color: #4ade80;
            background: #111;
        }

        /* Tab Panels */
        .tab-panel {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        .tab-panel.active { display: flex; flex-direction: column; }

        /* Mobile Tabs and Panels - Hidden on Desktop */
        .mobile-tab-bar {
            display: none;
        }
        .mobile-panel {
            display: none;
        }

        header {
            text-align: center; padding: 20px 0;
            border-bottom: 1px solid #222; margin-bottom: 20px;
        }
        header h1 { font-size: 20px; font-weight: normal; color: #fff; }
        header p { color: #666; margin-top: 4px; font-size: 12px; }

        .status {
            display: inline-block; padding: 4px 12px;
            border-radius: 12px; font-size: 12px; margin-top: 12px;
        }
        .status.connected { background: #1a3a1a; color: #4ade80; }
        .status.connecting { background: #3a3a1a; color: #facc15; }
        .status.disconnected { background: #3a1a1a; color: #f87171; }

        #feed {
            display: flex; flex-direction: column;
            gap: 8px; padding-bottom: 40px;
        }
        /* No extra padding needed - banner is sticky now */

        /* Event Cards */
        .event {
            padding: 12px 16px; border-radius: 8px;
            background: #111; border-left: 3px solid #333;
            animation: fadeIn 0.2s ease-out;
            transition: background 0.15s;
            position: relative;
        }
        .event:hover { background: #161616; }
        .event.expanded { background: #1a1a1a; }
        .event.expanded .event-content { max-height: none; }
        .event.expanded .result-content { max-height: none; }
        .event.expanded .thinking-text { max-height: none; }
        .event .expand-hint {
            display: none;
        }

        /* Expand button */
        .expand-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            color: #888;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.15s, background 0.15s;
            z-index: 2;
            line-height: 1;
        }
        .event:hover .expand-btn { opacity: 1; }
        .expand-btn:hover { background: #333; color: #fff; }
        .event.expanded .expand-btn { opacity: 1; background: #333; color: #fff; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .event-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 8px; font-size: 12px; color: #666;
        }
        .event-label {
            display: flex; align-items: center; gap: 8px;
        }
        .event-icon {
            font-size: 14px; width: 20px; text-align: center;
        }
        .event-type { text-transform: uppercase; font-weight: 600; }

        /* Tool-specific colors */
        .event.thinking { border-left-color: #60a5fa; }
        .event.thinking .event-type { color: #60a5fa; }

        .event.read { border-left-color: #a78bfa; }
        .event.read .event-type { color: #a78bfa; }
        .event.read .event-icon { color: #a78bfa; }

        .event.write { border-left-color: #f472b6; }
        .event.write .event-type { color: #f472b6; }
        .event.write .event-icon { color: #f472b6; }

        .event.edit { border-left-color: #fb923c; }
        .event.edit .event-type { color: #fb923c; }
        .event.edit .event-icon { color: #fb923c; }

        .event.bash { border-left-color: #4ade80; }
        .event.bash .event-type { color: #4ade80; }
        .event.bash .event-icon { color: #4ade80; }

        .event.grep, .event.glob { border-left-color: #fbbf24; }
        .event.grep .event-type, .event.glob .event-type { color: #fbbf24; }
        .event.grep .event-icon, .event.glob .event-icon { color: #fbbf24; }

        .event.task { border-left-color: #22d3ee; }
        .event.task .event-type { color: #22d3ee; }
        .event.task .event-icon { color: #22d3ee; }

        .event.todo { border-left-color: #a3e635; }
        .event.todo .event-type { color: #a3e635; }
        .event.todo .event-icon { color: #a3e635; }

        .event.result { border-left-color: #10b981; }
        .event.result .event-type { color: #10b981; }

        .event.system { border-left-color: #8b5cf6; opacity: 0.7; }
        .event.system .event-type { color: #8b5cf6; }

        .event.generic-tool { border-left-color: #f59e0b; }
        .event.generic-tool .event-type { color: #f59e0b; }

        /* Content styling */
        .event-content {
            font-size: 13px;
        }

        .file-path {
            color: #888;
        }
        .file-name {
            color: #fff;
            font-weight: 500;
        }
        .line-range {
            color: #666;
            font-size: 11px;
            margin-left: 8px;
        }

        .command-block {
            background: #0d1117;
            border: 1px solid #21262d;
            border-radius: 6px;
            padding: 8px 12px;
            margin-top: 4px;
            overflow-x: auto;
        }
        .command-text {
            color: #7ee787;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .command-desc {
            color: #666;
            font-size: 11px;
            margin-top: 4px;
        }

        .search-pattern {
            background: #1a1a2e;
            color: #fbbf24;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: inherit;
        }
        .search-path {
            color: #888;
            margin-left: 8px;
        }

        .task-agent {
            background: #0d2a3a;
            color: #22d3ee;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            margin-right: 8px;
        }
        .task-prompt {
            color: #aaa;
            font-style: italic;
        }

        .todo-list {
            margin-top: 4px;
        }
        .todo-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px 0;
            font-size: 12px;
        }
        .todo-status {
            font-size: 10px;
        }
        .todo-status.completed { color: #4ade80; }
        .todo-status.in_progress { color: #fbbf24; }
        .todo-status.pending { color: #666; }

        .result-content {
            color: #888;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 150px;
            overflow: hidden;
        }

        .thinking-text {
            color: #c4c4c4;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 200px;
            overflow: hidden;
        }

        .idle-notice {
            text-align: center;
            color: #444;
            padding: 40px;
            font-style: italic;
        }

        .bytes-info {
            color: #666;
            font-size: 11px;
            margin-left: 8px;
        }

        /* Hidden WIP features */
        .marbles-panel,
        [data-panel="marbles-panel"],
        [data-tab="marbles"],
        .avatar-view,
        .avatar-panel,
        #toggle-avatar,
        #toggle-feed,
        [data-tab="avatar"],
        #mobile-avatar-panel,
        #mobile-marbles-panel { display: none !important; }

        /* Marbles Panel */
        .marbles-panel {
            align-items: center;
            justify-content: center;
            background: #050508;
            flex: 1;
            min-height: 0;
        }
        .marbles-panel.active {
            display: flex;
        }
        #marbles-canvas {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            aspect-ratio: 450 / 900;
            display: block;
        }

        /* Avatar Panel */
        .avatar-panel {
            align-items: center;
            justify-content: center;
            background: #050508;
            flex: 1;
            min-height: 0;
            padding: 0;
        }
        .avatar-panel.active {
            display: flex;
        }
        .avatar-panel iframe {
            width: 100%;
            height: 100%;
            max-width: 500px;
            max-height: 500px;
            aspect-ratio: 1;
            border: none;
            border-radius: 8px;
        }

        /* Beads Panel */
        .beads-panel {
            flex: 1;
        }
        .beads-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #222;
        }
        .beads-toolbar label {
            font-size: 11px;
            color: #888;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .beads-toolbar input[type="checkbox"] {
            accent-color: #4ade80;
        }
        .beads-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .bead-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: #111;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .bead-item:hover { background: #1a1a1a; }
        .bead-status-icon {
            flex-shrink: 0;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            border-radius: 50%;
        }
        .bead-status-icon.open { background: #1a2a4a; color: #3b82f6; }
        .bead-status-icon.in_progress { background: #3a3a1a; color: #fbbf24; animation: pulse 1.5s ease-in-out infinite; }
        .bead-status-icon.closed { background: #1a2a1a; color: #4ade80; }
        .bead-status-icon.tombstone { background: #1a1a1a; color: #666; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .bead-item-title {
            flex: 1;
            font-size: 12px;
            color: #ddd;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }
        .bead-item-time {
            flex-shrink: 0;
            font-size: 10px;
            color: #555;
        }
        .beads-empty {
            color: #666;
            text-align: center;
            padding: 40px 20px;
            font-style: italic;
        }

        /* Mobile Layout */
        @media (max-width: 800px) {
            .feed-screen.active { display: flex; }

            .main-layout {
                flex-direction: column;
            }

            /* Mobile Tab Bar at top */
            .mobile-tab-bar {
                display: flex;
                border-bottom: 1px solid #222;
                background: #0a0a0a;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .mobile-tab-bar .tab-btn {
                flex: 1;
                padding: 14px 8px;
            }

            /* Hide desktop elements on mobile */
            .sidebar-column {
                display: none;
            }
            .main-toggle-bar {
                display: none;
            }

            /* Main column becomes full width on mobile */
            .main-column {
                flex: 1;
                display: none;  /* Hidden by default, shown when feed tab active */
            }
            .main-column.mobile-active {
                display: flex;
            }

            /* Feed view adjustments for mobile */
            .feed-view {
                padding: 12px;
            }
            .feed-view header {
                padding-top: 10px;
            }

            /* Hide desktop avatar view on mobile */
            .avatar-view {
                display: none !important;
            }

            /* Mobile tab panels */
            .mobile-panel {
                display: none;
                flex: 1;
                overflow-y: auto;
                padding: 16px;
            }
            .mobile-panel.active {
                display: flex;
                flex-direction: column;
            }

            /* Avatar panel mobile - center the iframe */
            .mobile-panel.avatar-panel.active {
                align-items: center;
                justify-content: center;
                padding: 8px;
            }
            .mobile-panel.avatar-panel iframe {
                max-width: calc(100vw - 16px);
                max-height: calc(100vw - 16px);
            }
        }

        /* Event detail modal (works on all screen sizes) */
        .event-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 250;
            overflow-y: auto;
            padding: 60px 20px 20px;
        }
        .event-modal.visible {
            display: block;
        }
        .event-modal-close {
            position: fixed;
            top: 12px;
            right: 12px;
            width: 40px;
            height: 40px;
            font-size: 20px;
            background: #333;
            border: none;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            z-index: 251;
        }
        .event-modal-close:hover {
            background: #444;
        }
        .event-modal-content {
            max-width: 800px;
            margin: 0 auto;
        }
        .event-modal-content .event {
            background: #1a1a1a;
            cursor: default;
        }
        .event-modal-content .event:hover {
            background: #1a1a1a;
        }
        .event-modal-content .event-content,
        .event-modal-content .result-content,
        .event-modal-content .thinking-text {
            max-height: none !important;
        }
        /* Show full content in modal - handled by JS */

        .panel-heading {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #222;
        }
        .panel-heading:not(:first-child) { margin-top: 20px; }

        .filter-group { display: flex; flex-direction: column; gap: 4px; }

        .filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .filter-item:hover { background: #1a1a1a; }
        .filter-item.disabled { opacity: 0.4; }
        .filter-item.disabled .filter-icon,
        .filter-item.disabled .filter-label { opacity: 0.5; }

        .filter-checkbox {
            width: 14px;
            height: 14px;
            border: 1px solid #444;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: transparent;
            transition: all 0.15s;
        }
        .filter-item:not(.disabled) .filter-checkbox {
            background: #2a4a2a;
            border-color: #4ade80;
            color: #4ade80;
        }

        .filter-icon { font-size: 14px; width: 18px; text-align: center; }
        .filter-label { font-size: 12px; color: #aaa; }
        .filter-item:not(.disabled) .filter-label { color: #ddd; }

        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
        }
        .toggle-label { font-size: 12px; color: #aaa; }

        .toggle-switch {
            width: 36px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
        }
        .toggle-switch.on { background: #2a4a2a; }
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: #666;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.2s;
        }
        .toggle-switch.on::after {
            left: 18px;
            background: #4ade80;
        }

        .filter-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        .filter-btn {
            flex: 1;
            padding: 6px 8px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            color: #888;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .filter-btn:hover { background: #222; color: #fff; }

        /* Stats Panel */
        .stats-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 8px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
        }
        .stat-label {
            font-size: 11px;
            color: #666;
        }
        .stat-value {
            font-size: 12px;
            color: #ddd;
            font-weight: 500;
        }
        .stat-value.highlight {
            color: #4ade80;
        }
        .stat-value.warning {
            color: #fbbf24;
        }
        .stat-value.danger {
            color: #f87171;
        }

        /* Usage progress bars */
        .usage-section {
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .usage-row {
            margin-bottom: 10px;
        }
        .usage-label {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }
        .usage-percent {
            color: #ddd;
            font-weight: 500;
        }
        .usage-bar {
            position: relative;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        .week-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 1px;
            z-index: 1;
            transition: left 0.3s ease;
        }
        .usage-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .usage-bar-fill.normal {
            background: linear-gradient(90deg, #4ade80, #22c55e);
        }
        .usage-bar-fill.warning {
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
        }
        .usage-bar-fill.danger {
            background: linear-gradient(90deg, #f87171, #ef4444);
        }
        .usage-unavailable {
            font-size: 11px;
            color: #666;
            font-style: italic;
        }
        .usage-updated {
            font-size: 10px;
            color: #666;
            margin-top: 8px;
        }

        .context-bar {
            width: 60px;
            height: 6px;
            background: #222;
            border-radius: 3px;
            overflow: hidden;
            display: inline-block;
            vertical-align: middle;
            margin-right: 6px;
        }
        .context-bar-fill {
            height: 100%;
            background: #4ade80;
            transition: width 0.3s, background 0.3s;
        }
        .context-bar-fill.warning { background: #fbbf24; }
        .context-bar-fill.danger { background: #f87171; }

        /* Task viewing banner - sticky to top of feed */
        .task-banner {
            display: none;
            position: sticky;
            top: 0;
            background: linear-gradient(135deg, #1a2a3a 0%, #0d1a2a 100%);
            border: 1px solid #22d3ee;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 8px;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            z-index: 50;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .task-banner.visible { display: flex; }
        .task-banner-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .task-banner-icon {
            font-size: 20px;
        }
        .task-banner-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .task-banner-label {
            font-size: 11px;
            color: #22d3ee;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .task-banner-title {
            font-size: 14px;
            color: #fff;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            max-width: 300px;
        }
        .task-banner-back {
            background: #1a3a4a;
            border: 1px solid #22d3ee;
            border-radius: 6px;
            color: #22d3ee;
            padding: 8px 16px;
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .task-banner-back:hover {
            background: #22d3ee;
            color: #000;
        }


        /* Jump to bottom button */
        .jump-bottom {
            position: fixed;
            bottom: 24px;
            right: calc(350px + 24px); /* Position left of sidebar */
            background: #222;
            border: 1px solid #444;
            border-radius: 24px;
            color: #fff;
            padding: 10px 18px;
            font-family: inherit;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transform: translateY(80px);
            opacity: 0;
            transition: transform 0.2s ease, opacity 0.2s ease, background 0.15s;
            z-index: 99;
        }
        .jump-bottom:hover {
            background: #333;
        }
        .jump-bottom.visible {
            transform: translateY(0);
            opacity: 1;
        }
        .jump-bottom-arrow {
            font-size: 16px;
        }

        @media (max-width: 800px) {
            .jump-bottom {
                right: 12px;
                bottom: 16px;
                padding: 8px 14px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- Auth Screen -->
    <div id="auth-screen" class="auth-screen">
        <h1>Wendy's Brain</h1>
        <p>Enter the code to watch Wendy think</p>
        <form class="auth-form" onsubmit="handleAuth(event)">
            <input type="text" id="code-input" placeholder="Code word" autocomplete="off" autofocus>
            <button type="submit">Enter</button>
        </form>
        <div id="auth-error" class="auth-error"></div>
    </div>

    <!-- Feed Screen -->
    <div id="feed-screen" class="feed-screen">
        <!-- Event detail modal (for clicking marbles) -->
        <div id="event-modal" class="event-modal">
            <button class="event-modal-close" onclick="closeEventModal()">‚úï</button>
            <div id="event-modal-content" class="event-modal-content"></div>
        </div>

        <!-- Mobile Tab Bar -->
        <div class="mobile-tab-bar">
            <button class="tab-btn active" data-tab="feed" onclick="switchMobileTab('feed')">Feed</button>
            <button class="tab-btn" data-tab="settings" onclick="switchMobileTab('settings')">Settings</button>
            <button class="tab-btn" data-tab="avatar" onclick="switchMobileTab('avatar')">Avatar</button>
            <button class="tab-btn" data-tab="beads" onclick="switchMobileTab('beads')">Beads</button>
            <button class="tab-btn" data-tab="marbles" onclick="switchMobileTab('marbles')">Marbles</button>
        </div>

        <!-- Main Layout -->
        <div class="main-layout">
            <!-- Main Column: Feed/Avatar toggle -->
            <div class="main-column mobile-active">
                <!-- Toggle bar -->
                <div class="main-toggle-bar">
                    <button id="toggle-feed" class="main-toggle-btn active" onclick="switchMainView('feed')">Feed</button>
                    <button id="toggle-avatar" class="main-toggle-btn" onclick="switchMainView('avatar')">Avatar</button>
                    <span id="status" class="status connecting">Connecting...</span>
                </div>

                <!-- Feed View -->
                <div id="feed-view" class="feed-view">
                    <header>
                        <h1>Wendy's Brain</h1>
                        <p>Real-time Claude Code session</p>
                    </header>

                    <!-- Task viewing banner -->
                    <div id="task-banner" class="task-banner">
                        <div class="task-banner-info">
                            <span class="task-banner-icon">üîß</span>
                            <div class="task-banner-text">
                                <span class="task-banner-label">Viewing Task Output</span>
                                <span id="task-banner-title" class="task-banner-title">-</span>
                            </div>
                        </div>
                        <button class="task-banner-back" onclick="backToWendy()">‚Üê Back to Wendy</button>
                    </div>

                    <div id="feed">
                        <div class="idle-notice">Waiting for activity...</div>
                    </div>
                </div>

                <!-- Avatar View -->
                <div id="avatar-view" class="avatar-view">
                    <iframe id="avatar-iframe" src="/avatar/?embed" frameborder="0"></iframe>
                </div>
            </div>

            <!-- Right Column: Tabbed Sidebar (Desktop) -->
            <div class="sidebar-column">
                <div class="tab-bar">
                    <button class="tab-btn active" data-panel="settings-panel" onclick="switchDesktopTab('settings-panel')">Settings</button>
                    <button class="tab-btn" data-panel="marbles-panel" onclick="switchDesktopTab('marbles-panel')">Marbles</button>
                    <button class="tab-btn" data-panel="beads-panel" onclick="switchDesktopTab('beads-panel')">Beads</button>
                </div>

                <!-- Settings Panel -->
                <div id="settings-panel" class="tab-panel active">
                    <h3 class="panel-heading">Stats</h3>
                    <div class="stats-panel">
                        <div class="stat-row">
                            <span class="stat-label">Context</span>
                            <span class="stat-value" id="stat-context">-</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Session Cost</span>
                            <span class="stat-value" id="stat-cost">-</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Messages</span>
                            <span class="stat-value" id="stat-messages">-</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Viewers</span>
                            <span class="stat-value" id="stat-viewers">-</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Last Activity</span>
                            <span class="stat-value" id="stat-activity">-</span>
                        </div>
                    </div>

                    <div class="usage-section" id="usage-section">
                        <h3 class="panel-heading">Weekly Usage</h3>
                        <div id="usage-content">
                            <div class="usage-row">
                                <div class="usage-label">
                                    <span>All Models</span>
                                    <span class="usage-percent" id="usage-all-pct">-</span>
                                </div>
                                <div class="usage-bar">
                                    <div class="usage-bar-fill normal" id="usage-all-bar" style="width: 0%"></div>
                                    <div class="week-marker" id="week-marker-all" style="left: 0%"></div>
                                </div>
                            </div>
                            <div class="usage-row">
                                <div class="usage-label">
                                    <span>Sonnet Only</span>
                                    <span class="usage-percent" id="usage-sonnet-pct">-</span>
                                </div>
                                <div class="usage-bar">
                                    <div class="usage-bar-fill normal" id="usage-sonnet-bar" style="width: 0%"></div>
                                    <div class="week-marker" id="week-marker-sonnet" style="left: 0%"></div>
                                </div>
                            </div>
                            <div class="usage-updated" id="usage-updated"></div>
                        </div>
                    </div>

                    <h3 class="panel-heading">Settings</h3>
                    <div class="toggle-row">
                        <span class="toggle-label">Auto-scroll</span>
                        <div id="autoscroll-toggle" class="toggle-switch on" onclick="toggleAutoscroll()"></div>
                    </div>

                    <h3 class="panel-heading">Channels</h3>
                    <div class="filter-group" id="channel-filter-group">
                        <!-- Generated by JS -->
                    </div>
                    <div class="filter-actions">
                        <button class="filter-btn" onclick="setAllChannelFilters(true)">All</button>
                        <button class="filter-btn" onclick="setAllChannelFilters(false)">None</button>
                    </div>

                    <h3 class="panel-heading">Event Types</h3>
                    <div class="filter-group" id="filter-group">
                        <!-- Generated by JS -->
                    </div>
                    <div class="filter-actions">
                        <button class="filter-btn" onclick="setAllFilters(true)">All</button>
                        <button class="filter-btn" onclick="setAllFilters(false)">None</button>
                    </div>
                </div>

                <!-- Marbles Panel -->
                <div id="marbles-panel" class="tab-panel marbles-panel">
                    <canvas id="marbles-canvas"></canvas>
                </div>

                <!-- Beads Panel -->
                <div id="beads-panel" class="tab-panel beads-panel">
                    <div class="beads-toolbar">
                        <label><input type="checkbox" id="beads-show-completed" onchange="toggleShowCompleted()"> Show completed</label>
                    </div>
                    <div id="beads-list" class="beads-list">
                        <div class="beads-empty">No tasks</div>
                    </div>
                </div>
            </div>

            <!-- Mobile Panels (hidden on desktop) -->
            <div id="mobile-settings-panel" class="mobile-panel">
                <h3 class="panel-heading">Stats</h3>
                <div class="stats-panel">
                    <div class="stat-row">
                        <span class="stat-label">Context</span>
                        <span class="stat-value" id="stat-context-mobile">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Session Cost</span>
                        <span class="stat-value" id="stat-cost-mobile">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Messages</span>
                        <span class="stat-value" id="stat-messages-mobile">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Viewers</span>
                        <span class="stat-value" id="stat-viewers-mobile">-</span>
                    </div>
                </div>

                <div class="usage-section" id="usage-section-mobile">
                    <h3 class="panel-heading">Weekly Usage</h3>
                    <div id="usage-content-mobile">
                        <div class="usage-row">
                            <div class="usage-label">
                                <span>All Models</span>
                                <span class="usage-percent" id="usage-all-pct-mobile">-</span>
                            </div>
                            <div class="usage-bar">
                                <div class="usage-bar-fill normal" id="usage-all-bar-mobile" style="width: 0%"></div>
                                <div class="week-marker" id="week-marker-all-mobile" style="left: 0%"></div>
                            </div>
                        </div>
                        <div class="usage-row">
                            <div class="usage-label">
                                <span>Sonnet Only</span>
                                <span class="usage-percent" id="usage-sonnet-pct-mobile">-</span>
                            </div>
                            <div class="usage-bar">
                                <div class="usage-bar-fill normal" id="usage-sonnet-bar-mobile" style="width: 0%"></div>
                                <div class="week-marker" id="week-marker-sonnet-mobile" style="left: 0%"></div>
                            </div>
                        </div>
                        <div class="usage-updated" id="usage-updated-mobile"></div>
                    </div>
                </div>

                <h3 class="panel-heading">Settings</h3>
                <div class="toggle-row">
                    <span class="toggle-label">Auto-scroll</span>
                    <div id="autoscroll-toggle-mobile" class="toggle-switch on" onclick="toggleAutoscroll()"></div>
                </div>

                <h3 class="panel-heading">Channels</h3>
                <div class="filter-group" id="channel-filter-group-mobile">
                    <!-- Generated by JS -->
                </div>
                <div class="filter-actions">
                    <button class="filter-btn" onclick="setAllChannelFilters(true)">All</button>
                    <button class="filter-btn" onclick="setAllChannelFilters(false)">None</button>
                </div>

                <h3 class="panel-heading">Event Types</h3>
                <div class="filter-group" id="filter-group-mobile">
                    <!-- Generated by JS -->
                </div>
                <div class="filter-actions">
                    <button class="filter-btn" onclick="setAllFilters(true)">All</button>
                    <button class="filter-btn" onclick="setAllFilters(false)">None</button>
                </div>
            </div>

            <div id="mobile-avatar-panel" class="mobile-panel avatar-panel">
                <iframe id="avatar-iframe-mobile" src="/avatar/?embed" frameborder="0"></iframe>
            </div>

            <div id="mobile-beads-panel" class="mobile-panel beads-panel">
                <div class="beads-toolbar">
                    <label><input type="checkbox" id="beads-show-completed-mobile" onchange="toggleShowCompleted()"> Show completed</label>
                </div>
                <div id="beads-list-mobile" class="beads-list">
                    <div class="beads-empty">No tasks</div>
                </div>
            </div>

            <div id="mobile-marbles-panel" class="mobile-panel marbles-panel">
                <!-- Marbles canvas will be moved here dynamically when this tab is active -->
            </div>
        </div>

        <!-- Jump to bottom button -->
        <button id="jump-bottom" class="jump-bottom" onclick="jumpToBottom()">
            <span class="jump-bottom-arrow">‚Üì</span> Jump to bottom
        </button>
    </div>

    <script>
        const MAX_EVENTS = 100;
        let ws = null;
        let autoscroll = true;
        let userAtBottom = true;  // Track if user is scrolled to bottom

        // ==================== Filters & Settings ====================
        const eventTypes = [
            { id: 'thinking', icon: 'üí≠', label: 'Thinking', color: '#60a5fa' },
            { id: 'Read', icon: 'üìÑ', label: 'Read', color: '#a78bfa' },
            { id: 'Write', icon: '‚úèÔ∏è', label: 'Write', color: '#f472b6' },
            { id: 'Edit', icon: 'üîß', label: 'Edit', color: '#fb923c' },
            { id: 'Bash', icon: '‚å®Ô∏è', label: 'Bash', color: '#4ade80' },
            { id: 'Grep', icon: 'üîç', label: 'Grep', color: '#fbbf24' },
            { id: 'Glob', icon: 'üìÅ', label: 'Glob', color: '#fbbf24' },
            { id: 'Task', icon: 'ü§ñ', label: 'Task', color: '#22d3ee' },
            { id: 'TodoWrite', icon: 'üìã', label: 'Todos', color: '#a3e635' },
            { id: 'result', icon: 'üì®', label: 'Results', color: '#10b981' },
            { id: 'system', icon: '‚ö°', label: 'System', color: '#8b5cf6' },
        ];

        let filters = {};
        let channelFilters = {};

        // Known channels - will be populated from events
        const knownChannels = {
            '1050900592031178752': { name: 'Chat', icon: 'üí¨' },
            '1461429474250850365': { name: 'Coding', icon: 'üíª' },
        };

        function loadSettings() {
            try {
                const saved = localStorage.getItem('brain_settings');
                if (saved) {
                    const s = JSON.parse(saved);
                    filters = s.filters || {};
                    channelFilters = s.channelFilters || {};
                    autoscroll = s.autoscroll !== false;
                }
            } catch (e) {}
            // Default all filters to enabled
            eventTypes.forEach(t => {
                if (filters[t.id] === undefined) filters[t.id] = true;
            });
            // Default all channel filters to enabled
            Object.keys(knownChannels).forEach(id => {
                if (channelFilters[id] === undefined) channelFilters[id] = true;
            });
            // Safety: if ALL type filters are off or ALL channel filters are off, reset them
            const allTypesOff = eventTypes.every(t => filters[t.id] === false);
            const allChannelsOff = Object.keys(knownChannels).every(id => channelFilters[id] === false);
            if (allTypesOff) {
                eventTypes.forEach(t => filters[t.id] = true);
            }
            if (allChannelsOff) {
                Object.keys(knownChannels).forEach(id => channelFilters[id] = true);
            }
        }
        function saveSettings() {
            localStorage.setItem('brain_settings', JSON.stringify({ filters, channelFilters, autoscroll }));
        }

        function renderFilters() {
            const filterHtml = eventTypes.map(t => `
                <div class="filter-item ${filters[t.id] ? '' : 'disabled'}" onclick="toggleFilter('${t.id}')">
                    <div class="filter-checkbox">‚úì</div>
                    <span class="filter-icon">${t.icon}</span>
                    <span class="filter-label">${t.label}</span>
                </div>
            `).join('');

            // Update both desktop and mobile filter groups
            const desktopGroup = document.getElementById('filter-group');
            const mobileGroup = document.getElementById('filter-group-mobile');
            if (desktopGroup) desktopGroup.innerHTML = filterHtml;
            if (mobileGroup) mobileGroup.innerHTML = filterHtml;
        }

        function toggleFilter(id) {
            filters[id] = !filters[id];
            saveSettings();
            renderFilters();
            applyFiltersToFeed();
        }

        function setAllFilters(enabled) {
            eventTypes.forEach(t => filters[t.id] = enabled);
            saveSettings();
            renderFilters();
            applyFiltersToFeed();
        }

        function applyFiltersToFeed() {
            const events = document.querySelectorAll('#feed .event');
            events.forEach(el => {
                const type = el.dataset.eventType;
                const channelId = el.dataset.channelId;
                const typeVisible = filters[type] !== false;
                const channelVisible = !channelId || channelFilters[channelId] !== false;
                el.style.display = (typeVisible && channelVisible) ? '' : 'none';
            });
        }

        function renderChannelFilters() {
            const channelHtml = Object.entries(knownChannels).map(([id, ch]) => `
                <div class="filter-item ${channelFilters[id] ? '' : 'disabled'}" onclick="toggleChannelFilter('${id}')">
                    <div class="filter-checkbox">‚úì</div>
                    <span class="filter-icon">${ch.icon}</span>
                    <span class="filter-label">${ch.name}</span>
                </div>
            `).join('');

            const desktopGroup = document.getElementById('channel-filter-group');
            const mobileGroup = document.getElementById('channel-filter-group-mobile');
            if (desktopGroup) desktopGroup.innerHTML = channelHtml;
            if (mobileGroup) mobileGroup.innerHTML = channelHtml;
        }

        function toggleChannelFilter(id) {
            channelFilters[id] = !channelFilters[id];
            saveSettings();
            renderChannelFilters();
            applyFiltersToFeed();
        }

        function setAllChannelFilters(enabled) {
            Object.keys(knownChannels).forEach(id => channelFilters[id] = enabled);
            saveSettings();
            renderChannelFilters();
            applyFiltersToFeed();
        }

        // ==================== Tab Switching ====================
        let currentMobileTab = 'feed';
        let currentDesktopPanel = 'settings-panel';
        let marblesTabActive = window.innerWidth > 800;  // Track if marbles tab is visible (desktop defaults to marbles, mobile to feed)

        function switchMobileTab(tabName) {
            currentMobileTab = tabName;

            // Update tab buttons
            document.querySelectorAll('.mobile-tab-bar .tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
            });

            // Update panels - hide main-column and all mobile panels first
            const mainColumn = document.querySelector('.main-column');
            mainColumn.classList.remove('mobile-active');

            document.querySelectorAll('.mobile-panel').forEach(panel => {
                panel.classList.remove('active');
            });

            if (tabName === 'feed') {
                mainColumn.classList.add('mobile-active');
            } else if (tabName === 'settings') {
                document.getElementById('mobile-settings-panel').classList.add('active');
            } else if (tabName === 'avatar') {
                document.getElementById('mobile-avatar-panel').classList.add('active');
            } else if (tabName === 'beads') {
                document.getElementById('mobile-beads-panel').classList.add('active');
            } else if (tabName === 'marbles') {
                document.getElementById('mobile-marbles-panel').classList.add('active');
                // Move canvas to mobile panel
                const canvas = document.getElementById('marbles-canvas');
                const mobilePanel = document.getElementById('mobile-marbles-panel');
                if (canvas && mobilePanel) {
                    mobilePanel.appendChild(canvas);
                }
            }

            // Move canvas back to desktop panel when not on marbles
            if (tabName !== 'marbles') {
                const canvas = document.getElementById('marbles-canvas');
                const desktopPanel = document.getElementById('marbles-panel');
                if (canvas && desktopPanel && !desktopPanel.contains(canvas)) {
                    desktopPanel.appendChild(canvas);
                }
            }

            // Update marbles active state
            updateMarblesActiveState();
        }

        function switchDesktopTab(panelId) {
            currentDesktopPanel = panelId;

            // Update tab buttons
            document.querySelectorAll('.sidebar-column .tab-bar .tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.panel === panelId);
            });

            // Update panels
            document.querySelectorAll('.sidebar-column .tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === panelId);
            });

            // Update marbles active state
            updateMarblesActiveState();
        }

        // Main view toggle (Feed/Avatar on desktop)
        let currentMainView = 'feed';
        function switchMainView(view) {
            currentMainView = view;

            // Update toggle buttons
            document.getElementById('toggle-feed').classList.toggle('active', view === 'feed');
            document.getElementById('toggle-avatar').classList.toggle('active', view === 'avatar');

            // Update views
            document.getElementById('feed-view').classList.toggle('hidden', view !== 'feed');
            document.getElementById('avatar-view').classList.toggle('active', view === 'avatar');
        }

        function updateMarblesActiveState() {
            const isMobile = window.innerWidth <= 800;
            if (isMobile) {
                marblesTabActive = currentMobileTab === 'marbles';
            } else {
                marblesTabActive = currentDesktopPanel === 'marbles-panel';
            }

            // Start or stop animation based on tab visibility
            if (marblesTabActive && !marblesAnimating) {
                startMarblesAnimation();
            }
        }

        // Listen for resize to update marbles state
        window.addEventListener('resize', updateMarblesActiveState);

        function showEventModal(eventData) {
            if (!eventData) return;

            const modal = document.getElementById('event-modal');
            const content = document.getElementById('event-modal-content');

            // Render the event using existing renderEvent function
            const eventEl = renderEvent(eventData);
            if (eventEl) {
                // Force expanded state
                eventEl.classList.add('expanded');

                // Show full content, hide truncated versions
                eventEl.querySelectorAll('.command-full, .edit-full, .task-full').forEach(el => {
                    el.style.display = 'block';
                });
                eventEl.querySelectorAll('.command-truncated, .edit-truncated, .task-truncated').forEach(el => {
                    // Only hide if there's a full version sibling
                    const parent = el.parentElement;
                    const hasFull = parent && parent.querySelector('.command-full, .edit-full, .task-full');
                    if (hasFull) {
                        el.style.display = 'none';
                    }
                });

                content.innerHTML = '';
                content.appendChild(eventEl);
                modal.classList.add('visible');

                // Prevent body scroll while modal is open
                document.body.style.overflow = 'hidden';
            }
        }

        function closeEventModal() {
            const modal = document.getElementById('event-modal');
            modal.classList.remove('visible');
            document.body.style.overflow = '';
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeEventModal();
            }
            // Ctrl+Shift+C to trigger compaction (for testing)
            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                if (typeof triggerCompaction === 'function') {
                    triggerCompaction();
                }
            }
            // Ctrl+Shift+M to spawn 50 test marbles (for testing)
            if (e.ctrlKey && e.shiftKey && e.key === 'M') {
                e.preventDefault();
                if (typeof spawnTestMarbles === 'function') {
                    spawnTestMarbles(50);
                }
            }
        });

        // Close modal when clicking outside content
        document.getElementById('event-modal')?.addEventListener('click', (e) => {
            // Close if clicking the modal backdrop (not the content)
            if (e.target.id === 'event-modal') {
                closeEventModal();
            }
        });

        function toggleAutoscroll() {
            autoscroll = !autoscroll;
            // Update both desktop and mobile toggles
            document.querySelectorAll('#autoscroll-toggle, #autoscroll-toggle-mobile').forEach(toggle => {
                toggle.classList.toggle('on', autoscroll);
            });
            saveSettings();
        }

        // ==================== Jump to Bottom ====================
        let isAutoScrolling = false;

        function getScrollContainer() {
            // Feed-view is the scroll container
            return document.getElementById('feed-view');
        }

        function jumpToBottom() {
            const container = getScrollContainer();
            if (!container) return;
            isAutoScrolling = true;
            container.scrollTo({ top: container.scrollHeight, behavior: 'smooth' });
            userAtBottom = true;
            setTimeout(() => { isAutoScrolling = false; }, 500);
        }

        let scrollDebounce = null;
        function scrollToBottom() {
            const container = getScrollContainer();
            if (!container) return;
            isAutoScrolling = true;
            // Debounce rapid scroll calls
            if (scrollDebounce) clearTimeout(scrollDebounce);
            scrollDebounce = setTimeout(() => {
                container.scrollTo(0, container.scrollHeight);
                setTimeout(() => { isAutoScrolling = false; }, 200);
            }, 50);
        }

        function isNearBottom() {
            const container = getScrollContainer();
            if (!container) return true;
            const scrollBottom = container.scrollTop + container.clientHeight;
            const scrollHeight = container.scrollHeight;
            return scrollHeight - scrollBottom < 150;
        }

        function updateJumpButton() {
            const btn = document.getElementById('jump-bottom');
            if (!btn) return;
            const container = getScrollContainer();
            if (!container) return;
            const scrollBottom = container.scrollTop + container.clientHeight;
            const scrollHeight = container.scrollHeight;
            // Show button if more than 300px from bottom
            if (scrollHeight - scrollBottom > 300) {
                btn.classList.add('visible');
            } else {
                btn.classList.remove('visible');
            }
        }

        // Throttled scroll handler - track if user is at bottom
        let scrollTimeout;
        function setupScrollListener() {
            const container = getScrollContainer();
            if (!container) return;
            container.addEventListener('scroll', () => {
                // Ignore scroll events triggered by programmatic scrolling
                if (isAutoScrolling) return;
                if (scrollTimeout) return;
                scrollTimeout = setTimeout(() => {
                    updateJumpButton();
                    // Update userAtBottom - if they scroll near bottom, re-enable autoscroll
                    userAtBottom = isNearBottom();
                    scrollTimeout = null;
                }, 150);
            });
        }
        // Set up scroll listener after DOM is ready
        document.addEventListener('DOMContentLoaded', setupScrollListener);

        // ==================== Stats ====================
        let statsInterval = null;

        async function fetchStats() {
            try {
                const res = await fetch('/api/brain/stats', { headers: authHeaders() });
                if (!res.ok) return;
                const stats = await res.json();
                updateStatsDisplay(stats);
            } catch (e) {
                console.debug('Failed to fetch stats:', e);
            }
        }

        function updateStatsDisplay(stats) {
            const pct = stats.context_pct || 0;
            const barClass = pct > 80 ? 'danger' : pct > 50 ? 'warning' : '';
            const contextHtml = `
                <span class="context-bar"><span class="context-bar-fill ${barClass}" style="width:${Math.min(pct, 100)}%"></span></span>
                ${pct}%
            `;

            const cost = stats.session_cost || 0;
            const costText = cost > 0 ? `$${cost.toFixed(4)}` : '-';
            const msgText = stats.session_messages || 0;
            const viewersText = stats.viewers || 0;

            // Activity text
            let activityText = '-';
            let activityClass = 'stat-value';
            if (stats.last_activity) {
                const ago = Math.floor((Date.now() - stats.last_activity) / 1000);
                if (ago < 60) {
                    activityText = `${ago}s ago`;
                    activityClass = 'stat-value highlight';
                } else if (ago < 3600) {
                    activityText = `${Math.floor(ago / 60)}m ago`;
                } else {
                    activityText = `${Math.floor(ago / 3600)}h ago`;
                    activityClass = 'stat-value warning';
                }
            }

            // Update desktop stats
            const contextEl = document.getElementById('stat-context');
            if (contextEl) contextEl.innerHTML = contextHtml;
            const costEl = document.getElementById('stat-cost');
            if (costEl) costEl.textContent = costText;
            const msgEl = document.getElementById('stat-messages');
            if (msgEl) msgEl.textContent = msgText;
            const viewersEl = document.getElementById('stat-viewers');
            if (viewersEl) viewersEl.textContent = viewersText;
            const activityEl = document.getElementById('stat-activity');
            if (activityEl) {
                activityEl.textContent = activityText;
                activityEl.className = activityClass;
            }

            // Update mobile stats
            const contextElMobile = document.getElementById('stat-context-mobile');
            if (contextElMobile) contextElMobile.innerHTML = contextHtml;
            const costElMobile = document.getElementById('stat-cost-mobile');
            if (costElMobile) costElMobile.textContent = costText;
            const msgElMobile = document.getElementById('stat-messages-mobile');
            if (msgElMobile) msgElMobile.textContent = msgText;
            const viewersElMobile = document.getElementById('stat-viewers-mobile');
            if (viewersElMobile) viewersElMobile.textContent = viewersText;
        }

        function startStatsPolling() {
            if (statsInterval) return;
            fetchStats();
            fetchUsage();  // Also fetch usage on start
            statsInterval = setInterval(fetchStats, 5000);
        }

        function stopStatsPolling() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
        }

        // ==================== Usage Stats ====================

        let usageInterval = null;

        async function fetchUsage() {
            try {
                const res = await fetch('/api/brain/usage', { headers: authHeaders() });
                if (!res.ok) return;
                const data = await res.json();
                updateUsageDisplay(data);
            } catch (e) {
                console.debug('Failed to fetch usage:', e);
            }
        }

        function updateUsageDisplay(data) {
            if (!data.available) {
                // Show unavailable message
                ['', '-mobile'].forEach(suffix => {
                    const content = document.getElementById(`usage-content${suffix}`);
                    if (content) {
                        content.innerHTML = '<div class="usage-unavailable">Usage data not available yet</div>';
                    }
                });
                return;
            }

            const weekAll = data.week_all_percent || 0;
            const weekSonnet = data.week_sonnet_percent || 0;

            // Determine bar colors based on percentage
            function getBarClass(pct) {
                if (pct >= 80) return 'danger';
                if (pct >= 60) return 'warning';
                return 'normal';
            }

            // Update both desktop and mobile
            ['', '-mobile'].forEach(suffix => {
                // All models
                const allPct = document.getElementById(`usage-all-pct${suffix}`);
                const allBar = document.getElementById(`usage-all-bar${suffix}`);
                if (allPct) allPct.textContent = `${weekAll}%`;
                if (allBar) {
                    allBar.style.width = `${Math.min(weekAll, 100)}%`;
                    allBar.className = `usage-bar-fill ${getBarClass(weekAll)}`;
                }

                // Sonnet only
                const sonnetPct = document.getElementById(`usage-sonnet-pct${suffix}`);
                const sonnetBar = document.getElementById(`usage-sonnet-bar${suffix}`);
                if (sonnetPct) sonnetPct.textContent = `${weekSonnet}%`;
                if (sonnetBar) {
                    sonnetBar.style.width = `${Math.min(weekSonnet, 100)}%`;
                    sonnetBar.className = `usage-bar-fill ${getBarClass(weekSonnet)}`;
                }

                // Week progress marker - shows how far through the 7-day cycle we are
                if (data.week_all_resets) {
                    const resetDate = new Date(data.week_all_resets);
                    const now = new Date();
                    const msUntilReset = resetDate - now;
                    const sevenDaysMs = 7 * 24 * 60 * 60 * 1000;
                    const weekProgress = Math.max(0, Math.min(100, ((sevenDaysMs - msUntilReset) / sevenDaysMs) * 100));

                    const markerAll = document.getElementById(`week-marker-all${suffix}`);
                    const markerSonnet = document.getElementById(`week-marker-sonnet${suffix}`);
                    if (markerAll) markerAll.style.left = `${weekProgress}%`;
                    if (markerSonnet) markerSonnet.style.left = `${weekProgress}%`;
                }

                // Updated time and reset info
                const updated = document.getElementById(`usage-updated${suffix}`);
                if (updated) {
                    let info = [];
                    if (data.updated_at) {
                        // Add Z suffix if missing to indicate UTC
                        let ts = data.updated_at;
                        if (!ts.endsWith('Z') && !ts.includes('+')) ts += 'Z';
                        const date = new Date(ts);
                        const timeStr = date.toLocaleString([], {
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        info.push(`Updated: ${timeStr}`);
                    }
                    if (data.week_all_resets) {
                        // Convert ISO timestamp to local timezone
                        const resetDate = new Date(data.week_all_resets);
                        const resetStr = resetDate.toLocaleString([], {
                            weekday: 'short',
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        info.push(`Resets: ${resetStr}`);
                    }
                    updated.textContent = info.join(' | ');
                }
            });
        }

        function startUsagePolling() {
            if (usageInterval) return;
            fetchUsage();
            // Poll every 5 minutes (usage updates hourly, but check more often for manual refreshes)
            usageInterval = setInterval(fetchUsage, 300000);
        }

        function stopUsagePolling() {
            if (usageInterval) {
                clearInterval(usageInterval);
                usageInterval = null;
            }
        }

        // ==================== Auth ====================
        function getToken() { return localStorage.getItem('brain_token'); }
        function setToken(token) { localStorage.setItem('brain_token', token); }
        function clearToken() { localStorage.removeItem('brain_token'); }
        function getPassphrase() { return localStorage.getItem('brain_passphrase'); }
        function setPassphrase(p) { localStorage.setItem('brain_passphrase', p); }
        function clearPassphrase() { localStorage.removeItem('brain_passphrase'); }
        function authHeaders() {
            const t = getToken();
            return t ? { 'Authorization': 'Bearer ' + t } : {};
        }

        async function authenticate(code, savePassphrase = true) {
            console.log('[Auth] authenticate called, savePassphrase:', savePassphrase);
            const res = await fetch('/api/brain/auth', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ code })
            });
            if (!res.ok) {
                const err = await res.json().catch(() => ({}));
                throw new Error(err.detail || 'Invalid code');
            }
            const { token } = await res.json();
            setToken(token);
            if (savePassphrase) {
                console.log('[Auth] Saving passphrase to localStorage');
                setPassphrase(code);
                console.log('[Auth] Passphrase saved:', !!getPassphrase());
            }
            return true;
        }

        async function tryReauthenticate() {
            const passphrase = getPassphrase();
            if (!passphrase) return false;
            try {
                await authenticate(passphrase, false);
                console.log('Re-authenticated with stored passphrase');
                return true;
            } catch (e) {
                console.log('Re-auth failed:', e.message);
                clearPassphrase();
                return false;
            }
        }

        async function handleAuth(e) {
            e.preventDefault();
            const input = document.getElementById('code-input');
            const error = document.getElementById('auth-error');
            const code = input.value.trim();
            if (!code) return;
            error.textContent = '';
            input.disabled = true;
            try {
                await authenticate(code);
                showFeed();
                connect();
            } catch (e) {
                error.textContent = e.message || 'Authentication failed';
                input.disabled = false;
                input.focus();
            }
        }

        // ==================== UI ====================
        function showAuth() {
            document.getElementById('auth-screen').style.display = 'flex';
            document.getElementById('feed-screen').classList.remove('active');
            stopStatsPolling();
            stopTasksPolling();
            stopTaskLogPolling();
        }
        function showFeed() {
            document.getElementById('auth-screen').style.display = 'none';
            document.getElementById('feed-screen').classList.add('active');
            startStatsPolling();
            startTasksPolling();
        }
        function setStatus(state, text) {
            const el = document.getElementById('status');
            el.className = 'status ' + state;
            el.textContent = text || state.charAt(0).toUpperCase() + state.slice(1);
        }

        // ==================== Rendering ====================
        function formatTime(ts) { return new Date(ts).toLocaleTimeString(); }
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        function escapeJsString(str) {
            // Escape for use inside single-quoted JS string literals
            if (!str) return '';
            return str.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r');
        }
        function truncate(str, len = 200) {
            if (!str || str.length <= len) return str;
            return str.slice(0, len) + '...';
        }
        function normalizeContent(content) {
            if (content == null) return '';
            if (typeof content === 'string') return content;
            if (Array.isArray(content)) return content.map(c => (c && c.text) || (typeof c === 'string' ? c : JSON.stringify(c))).join('\n');
            if (typeof content === 'object') return JSON.stringify(content, null, 2);
            return String(content);
        }
        function basename(path) {
            const parts = path.split('/');
            return parts[parts.length - 1];
        }
        function dirname(path) {
            const parts = path.split('/');
            parts.pop();
            return parts.join('/') + '/';
        }

        // Tool-specific renderers
        const toolRenderers = {
            Read: (input) => {
                const path = input.file_path || '';
                const offset = input.offset;
                const limit = input.limit;
                let range = '';
                if (offset !== undefined || limit !== undefined) {
                    range = `<span class="line-range">lines ${offset || 0}-${(offset || 0) + (limit || '?')}</span>`;
                }
                return `<span class="file-path">${escapeHtml(dirname(path))}</span><span class="file-name">${escapeHtml(basename(path))}</span>${range}`;
            },

            Write: (input) => {
                const path = input.file_path || '';
                const content = input.content || '';
                const bytes = content.length;
                return `<span class="file-path">${escapeHtml(dirname(path))}</span><span class="file-name">${escapeHtml(basename(path))}</span><span class="bytes-info">${bytes} bytes</span>`;
            },

            Edit: (input) => {
                const path = input.file_path || '';
                const oldStrFull = input.old_string || '';
                const newStrFull = input.new_string || '';
                const oldStr = truncate(oldStrFull, 100);
                const newStr = truncate(newStrFull, 100);
                const isTruncated = oldStrFull.length > 100 || newStrFull.length > 100;
                return `<span class="file-path">${escapeHtml(dirname(path))}</span><span class="file-name">${escapeHtml(basename(path))}</span>
                    <div class="command-block" style="margin-top: 8px;">
                        <div class="edit-truncated">
                            <div style="color: #f87171;">- ${escapeHtml(oldStr)}</div>
                            <div style="color: #4ade80;">+ ${escapeHtml(newStr)}</div>
                        </div>
                        ${isTruncated ? `<div class="edit-full" style="display:none">
                            <div style="color: #f87171; white-space: pre-wrap;">- ${escapeHtml(oldStrFull)}</div>
                            <div style="color: #4ade80; white-space: pre-wrap;">+ ${escapeHtml(newStrFull)}</div>
                        </div>` : ''}
                    </div>`;
            },

            Bash: (input) => {
                const cmd = input.command || '';
                const desc = input.description || '';
                const isTruncated = cmd.length > 300;
                return `${desc ? `<div class="command-desc">${escapeHtml(desc)}</div>` : ''}
                    <div class="command-block">
                        <span class="command-text command-truncated">$ ${escapeHtml(truncate(cmd, 300))}</span>
                        ${isTruncated ? `<span class="command-text command-full" style="display:none">$ ${escapeHtml(cmd)}</span>` : ''}
                    </div>`;
            },

            Grep: (input) => {
                const pattern = input.pattern || '';
                const path = input.path || '.';
                return `<span class="search-pattern">${escapeHtml(truncate(pattern, 60))}</span><span class="search-path">in ${escapeHtml(path)}</span>`;
            },

            Glob: (input) => {
                const pattern = input.pattern || '';
                const path = input.path || '.';
                return `<span class="search-pattern">${escapeHtml(pattern)}</span><span class="search-path">in ${escapeHtml(path)}</span>`;
            },

            Task: (input) => {
                const agent = input.subagent_type || 'general';
                const promptFull = input.prompt || '';
                const prompt = truncate(promptFull, 150);
                const isTruncated = promptFull.length > 150;
                return `<span class="task-agent">${escapeHtml(agent)}</span>
                    <span class="task-prompt task-truncated">${escapeHtml(prompt)}</span>
                    ${isTruncated ? `<span class="task-prompt task-full" style="display:none;white-space:pre-wrap">${escapeHtml(promptFull)}</span>` : ''}`;
            },

            TodoWrite: (input) => {
                const todos = input.todos || [];
                if (todos.length === 0) return '<span style="color:#666">Cleared todos</span>';
                const statusIcons = { completed: '‚úì', in_progress: '‚óê', pending: '‚óã' };
                const items = todos.slice(0, 5).map(t => {
                    const icon = statusIcons[t.status] || '‚óã';
                    return `<div class="todo-item"><span class="todo-status ${t.status}">${icon}</span>${escapeHtml(truncate(t.content, 60))}</div>`;
                }).join('');
                const more = todos.length > 5 ? `<div style="color:#666;font-size:11px">+${todos.length - 5} more</div>` : '';
                return `<div class="todo-list">${items}${more}</div>`;
            }
        };

        const toolIcons = {
            Read: 'üìÑ', Write: '‚úèÔ∏è', Edit: 'üîß', Bash: '‚å®Ô∏è',
            Grep: 'üîç', Glob: 'üìÅ', Task: 'ü§ñ', TodoWrite: 'üìã'
        };

        const toolClasses = {
            Read: 'read', Write: 'write', Edit: 'edit', Bash: 'bash',
            Grep: 'grep', Glob: 'glob', Task: 'task', TodoWrite: 'todo'
        };

        function renderToolUse(block) {
            const name = block.name || 'Unknown';
            const input = block.input || {};
            const renderer = toolRenderers[name];
            const icon = toolIcons[name] || 'üîß';
            const cls = toolClasses[name] || 'generic-tool';

            let content;
            if (renderer) {
                content = renderer(input);
            } else {
                const inputJson = JSON.stringify(input, null, 2);
                content = `<span style="color:#f59e0b">${escapeHtml(name)}</span>
                    <div class="command-block result-content">${escapeHtml(inputJson)}</div>`;
            }

            return { cls, icon, name, content };
        }

        function renderEvent(data) {
            const { ts, event, channel_id } = data;
            if (!event) return null;

            const div = document.createElement('div');
            div.className = 'event';
            if (channel_id) div.dataset.channelId = channel_id;

            let icon = '';
            let type = '';
            let content = '';
            let cls = '';
            let filterType = '';  // Used for filtering

            if (event.type === 'ping') {
                return null;
            } else if (event.type === 'system') {
                cls = 'system';
                icon = '‚ö°';
                type = event.subtype || 'system';
                filterType = 'system';
                content = event.subtype === 'init' ? 'Session started' : escapeHtml(JSON.stringify(event));
            } else if (event.type === 'assistant') {
                const blocks = event.message?.content || [];
                for (const block of blocks) {
                    if (block.type === 'text' && block.text) {
                        cls = 'thinking';
                        icon = 'üí≠';
                        type = 'thinking';
                        filterType = 'thinking';
                        content = `<div class="thinking-text">${escapeHtml(block.text)}</div>`;
                    } else if (block.type === 'tool_use') {
                        const rendered = renderToolUse(block);
                        cls = rendered.cls;
                        icon = rendered.icon;
                        type = rendered.name;
                        filterType = rendered.name;  // Read, Write, Edit, Bash, etc.
                        content = rendered.content;
                    }
                }
            } else if (event.type === 'user') {
                const blocks = event.message?.content || [];
                for (const block of blocks) {
                    if (block.type === 'tool_result') {
                        cls = 'result';
                        icon = 'üì®';
                        type = 'result';
                        filterType = 'result';
                        const resultContent = normalizeContent(block.content);
                        content = `<div class="result-content">${escapeHtml(resultContent)}</div>`;
                    }
                }
            } else if (event.type === 'result') {
                cls = 'system';
                icon = '‚úÖ';
                type = 'complete';
                filterType = 'system';
                content = `Session complete (${event.num_turns || '?'} turns)`;
            }

            if (!type) return null;

            div.classList.add(cls);
            div.dataset.eventType = filterType;
            div.innerHTML = `
                <button class="expand-btn" onclick="event.stopPropagation(); toggleEventExpand(this.closest('.event'));" title="Expand/collapse">&#x25BC;</button>
                <div class="event-header">
                    <div class="event-label">
                        <span class="event-icon">${icon}</span>
                        <span class="event-type">${escapeHtml(type)}</span>
                    </div>
                    <span class="event-time">${formatTime(ts)}</span>
                </div>
                <div class="event-content">${content}</div>
            `;

            // Check if content is likely truncated (for thinking/result types)
            if (filterType === 'thinking' || filterType === 'result') {
                div.classList.add('truncated');
            }

            // Apply filters immediately
            const typeVisible = filters[filterType] !== false;
            const channelVisible = !channel_id || channelFilters[channel_id] !== false;
            if (!typeVisible || !channelVisible) {
                div.style.display = 'none';
            }

            return div;
        }

        // Track seen events to prevent duplicates on reconnect/replay
        const seenEvents = new Set();
        const MAX_SEEN_EVENTS = 500;

        function getEventKey(data) {
            // Create a unique key for this event
            const ts = data.ts || 0;
            const type = data.event?.type || '';
            const subtype = data.event?.subtype || '';
            const content = data.event?.message?.content;
            let contentKey = '';
            if (content && content[0]) {
                if (content[0].type === 'tool_use') {
                    contentKey = content[0].name + (content[0].input?.file_path || content[0].input?.command || '').slice(0, 50);
                } else if (content[0].type === 'text') {
                    contentKey = content[0].text?.slice(0, 50) || '';
                } else if (content[0].type === 'tool_result') {
                    const resultContent = normalizeContent(content[0].content);
                    contentKey = 'result-' + resultContent.slice(0, 30);
                }
            }
            return `${ts}-${type}-${subtype}-${contentKey}`;
        }

        function addEvent(data) {
            // Deduplicate events
            const eventKey = getEventKey(data);
            if (seenEvents.has(eventKey)) {
                return false; // Already processed this event
            }
            seenEvents.add(eventKey);

            // Keep set from growing too large
            if (seenEvents.size > MAX_SEEN_EVENTS) {
                const arr = Array.from(seenEvents);
                seenEvents.clear();
                arr.slice(-250).forEach(k => seenEvents.add(k));
            }

            const feed = document.getElementById('feed');
            const idle = feed.querySelector('.idle-notice');
            if (idle) idle.remove();

            const el = renderEvent(data);
            if (!el) return;

            feed.appendChild(el);
            while (feed.children.length > MAX_EVENTS) {
                feed.removeChild(feed.firstChild);
            }

            // Only autoscroll if enabled AND user is at bottom
            if (autoscroll && userAtBottom) {
                scrollToBottom();
            }
            return true;  // Event was new
        }

        function toggleEventExpand(el) {
            const isExpanded = el.classList.toggle('expanded');

            // Update expand button icon
            const btn = el.querySelector('.expand-btn');
            if (btn) btn.innerHTML = isExpanded ? '&#x25B2;' : '&#x25BC;';

            // Toggle truncated/full content visibility
            const truncatedEls = el.querySelectorAll('.command-truncated, .edit-truncated, .task-truncated');
            const fullEls = el.querySelectorAll('.command-full, .edit-full, .task-full');

            truncatedEls.forEach(e => e.style.display = isExpanded ? 'none' : '');
            fullEls.forEach(e => e.style.display = isExpanded ? '' : 'none');
        }

        // Close expanded cards when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.event') && !e.target.closest('.event-modal')) {
                document.querySelectorAll('#feed .event.expanded').forEach(el => {
                    el.classList.remove('expanded');
                    const btn = el.querySelector('.expand-btn');
                    if (btn) btn.innerHTML = '&#x25BC;';
                    el.querySelectorAll('.command-truncated, .edit-truncated, .task-truncated').forEach(e => e.style.display = '');
                    el.querySelectorAll('.command-full, .edit-full, .task-full').forEach(e => e.style.display = 'none');
                });
            }
        });

        // ==================== WebSocket ====================
        function connect() {
            const token = getToken();
            if (!token) { showAuth(); return; }

            setStatus('connecting', 'Connecting...');
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(protocol + '//' + location.host + '/ws/brain?token=' + encodeURIComponent(token));

            let wasConnected = false;
            ws.onopen = () => { wasConnected = true; setStatus('connected', 'Connected'); };
            ws.onclose = async (e) => {
                ws = null;
                // Auth error codes that mean token is definitely invalid
                const authErrorCodes = [4001, 4003, 1008, 3000];
                if (authErrorCodes.includes(e.code)) {
                    // Token invalid or expired - try to re-auth with stored passphrase
                    clearToken();
                    setStatus('disconnected', 'Re-authenticating...');
                    const reauthed = await tryReauthenticate();
                    if (reauthed) {
                        connect();
                    } else {
                        showAuth();
                        document.getElementById('auth-error').textContent = 'Session expired';
                    }
                } else if (e.code === 4002) {
                    setStatus('disconnected', 'Server full');
                } else {
                    setStatus('disconnected', 'Disconnected');
                    // Don't auto-reconnect if viewing a task
                    if (!viewingTaskId) {
                        setTimeout(connect, 3000);
                    }
                }
            };
            ws.onerror = () => { /* handled in onclose */ };
            ws.onmessage = (e) => {
                try {
                    const data = JSON.parse(e.data);
                    if (data.type === 'ping') { ws.send('pong'); }
                    else { addEvent(data); }
                } catch (err) { console.error('Parse error:', err); }
            };
        }

        // ==================== Tasks (Beads) ====================
        let tasksInterval = null;
        let viewingTaskId = null;
        let viewingTaskTitle = null;
        let taskLogOffset = 0;
        let taskLogInterval = null;
        let savedFeedContent = null;  // Save feed when viewing task

        let knownBeads = new Set();  // Track beads we've seen
        let initialBeadsFetched = false;  // Don't spawn marbles for pre-existing beads

        async function fetchTasks() {
            try {
                const res = await fetch('/api/brain/beads', { headers: authHeaders() });
                if (!res.ok) return;
                const data = await res.json();
                const beads = data.beads || [];
                renderTasksList(beads);

                // Spawn/update bead marbles
                for (const bead of beads) {
                    if (beadMarbles.has(bead.id)) {
                        // Update existing marble's status
                        const marble = beadMarbles.get(bead.id);
                        marble.beadStatus = bead.status;
                    } else if (!knownBeads.has(bead.id)) {
                        knownBeads.add(bead.id);
                        // Only spawn marble if this isn't the initial fetch
                        if (initialBeadsFetched) {
                            spawnBeadMarble(bead);
                        }
                    }
                }
                initialBeadsFetched = true;
            } catch (e) {
                console.debug('Failed to fetch tasks:', e);
            }
        }

        function spawnBeadMarble(bead) {
            if (!marblesCanvas || marblesWidth === 0) return;

            // Spawn from random position at top
            const x = Math.random() * (marblesWidth - MARBLE_RADIUS * 8) + MARBLE_RADIUS * 4;
            const y = MARBLE_RADIUS * 4;

            const marble = new Marble(x, y, 'bead', bead.title || 'Task', {
                radius: MARBLE_RADIUS * 3,  // 3x size
                color: beadStatusColors[bead.status] || beadStatusColors.open,
                beadId: bead.id,
                beadStatus: bead.status,
            });
            marbles.push(marble);
            beadMarbles.set(bead.id, marble);
        }

        function formatRelativeTime(isoString) {
            if (!isoString) return '';
            try {
                const date = new Date(isoString);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'just now';
                if (diffMins < 60) return `${diffMins}m ago`;
                if (diffHours < 24) return `${diffHours}h ago`;
                if (diffDays < 7) return `${diffDays}d ago`;
                return date.toLocaleDateString();
            } catch {
                return '';
            }
        }

        let showCompletedBeads = false;
        let lastBeadsList = [];

        function toggleShowCompleted() {
            showCompletedBeads = !showCompletedBeads;
            document.querySelectorAll('#beads-show-completed, #beads-show-completed-mobile').forEach(el => {
                el.checked = showCompletedBeads;
            });
            renderTasksList(lastBeadsList);
        }

        function renderTasksList(tasks) {
            lastBeadsList = tasks;

            // Sort: in_progress first, then open, then closed, then tombstone
            const statusOrder = { 'in_progress': 0, 'open': 1, 'closed': 2, 'tombstone': 3 };
            const sorted = [...tasks].sort((a, b) => (statusOrder[a.status] ?? 9) - (statusOrder[b.status] ?? 9));

            // Filter if not showing completed
            const filtered = showCompletedBeads
                ? sorted
                : sorted.filter(t => t.status === 'open' || t.status === 'in_progress');

            const statusIcons = {
                'in_progress': '&#9654;',
                'open': '&#9679;',
                'closed': '&#10003;',
                'tombstone': '&#8212;'
            };

            const html = filtered.length === 0
                ? '<div class="beads-empty">No active tasks</div>'
                : filtered.map(task => {
                    const icon = statusIcons[task.status] || '?';
                    const timeAgo = formatRelativeTime(task.updated || task.created);
                    return `
                        <div class="bead-item" onclick="viewTask('${task.id}', '${escapeJsString(task.title)}')">
                            <span class="bead-status-icon ${task.status}">${icon}</span>
                            <span class="bead-item-title" title="${escapeHtml(task.title)}">${escapeHtml(task.title)}</span>
                            <span class="bead-item-time">${timeAgo}</span>
                        </div>
                    `;
                }).join('');

            // Update both desktop and mobile beads lists
            const desktopList = document.getElementById('beads-list');
            const mobileList = document.getElementById('beads-list-mobile');
            if (desktopList) desktopList.innerHTML = html;
            if (mobileList) mobileList.innerHTML = html;
        }

        function viewTask(taskId, title) {
            viewingTaskId = taskId;
            viewingTaskTitle = title;
            taskLogOffset = 0;

            // On mobile, switch to the feed tab
            if (window.innerWidth <= 800) {
                switchMobileTab('feed');
            }

            // Add viewing-task class for styling
            document.getElementById('feed-screen').classList.add('viewing-task');

            // Update banner
            document.getElementById('task-banner').classList.add('visible');
            document.getElementById('task-banner-title').textContent = `${taskId}: ${title}`;

            // Save feed content before clearing
            const feed = document.getElementById('feed');
            savedFeedContent = feed.innerHTML;
            feed.innerHTML = '<div class="idle-notice">Loading task output...</div>';

            // Update task list to show which one is being viewed
            fetchTasks();

            // Disconnect WebSocket while viewing task to prevent Wendy events mixing in
            if (ws) {
                ws.close();
                ws = null;
            }

            // Start polling task log
            startTaskLogPolling();
        }

        function backToWendy() {
            // Stop task log polling
            stopTaskLogPolling();

            // Remove viewing-task class
            document.getElementById('feed-screen').classList.remove('viewing-task');

            // Hide banner
            document.getElementById('task-banner').classList.remove('visible');

            // Restore saved feed content
            const feed = document.getElementById('feed');
            if (savedFeedContent) {
                feed.innerHTML = savedFeedContent;
                savedFeedContent = null;
            }

            viewingTaskId = null;
            viewingTaskTitle = null;

            // Re-fetch tasks to update viewing state
            fetchTasks();

            // Reconnect WebSocket
            connect();

            // Reset scroll position
            userAtBottom = true;
        }

        async function fetchTaskLog() {
            if (!viewingTaskId) return;

            try {
                const res = await fetch(`/api/brain/beads/${viewingTaskId}/log?offset=${taskLogOffset}`, { headers: authHeaders() });
                if (!res.ok) return;
                const data = await res.json();

                if (data.log) {
                    appendTaskLog(data.log);
                }
                taskLogOffset = data.offset;

                // If task is complete, slow down polling
                if (data.complete && taskLogInterval) {
                    clearInterval(taskLogInterval);
                    taskLogInterval = setInterval(fetchTaskLog, 5000);
                }
            } catch (e) {
                console.debug('Failed to fetch task log:', e);
            }
        }

        function appendTaskLog(text) {
            const feed = document.getElementById('feed');
            const idle = feed.querySelector('.idle-notice');
            if (idle) idle.remove();

            // Split by lines and group them intelligently
            const lines = text.split('\n');
            let plainTextBuffer = [];  // Accumulate non-JSON lines

            function flushPlainTextBuffer() {
                if (plainTextBuffer.length === 0) return;

                const content = plainTextBuffer.join('\n').trim();
                if (!content) {
                    plainTextBuffer = [];
                    return;
                }

                // Detect type based on content
                let icon = 'üìù';
                let type = 'log';
                let cssClass = 'result';

                // Check if it's a header block (Task:, Priority:, Model:, Started:)
                const isHeader = content.includes('Task:') && (
                    content.includes('Priority:') || content.includes('Model:') || content.includes('Started:')
                );

                if (isHeader) {
                    icon = 'üìã';
                    type = 'task info';
                    cssClass = 'system';
                } else if (content.includes('[TOOL]') || content.includes('Tool:') || /^(Read|Write|Edit|Bash|Grep|Glob):/im.test(content)) {
                    icon = '‚å®Ô∏è';
                    type = 'tool';
                    cssClass = 'bash';
                } else if (content.includes('[THINKING]') || content.startsWith('Thinking:')) {
                    icon = 'üí≠';
                    type = 'thinking';
                    cssClass = 'thinking';
                } else if (content.includes('[ERROR]') || /\berror\b/i.test(content)) {
                    icon = '‚ùå';
                    type = 'error';
                    cssClass = 'system';
                } else if (/^=+$/.test(content) || /^-+$/.test(content)) {
                    // Skip pure separator lines
                    plainTextBuffer = [];
                    return;
                } else if (content.startsWith('>') || content.includes('Result:') || content.includes('Output:')) {
                    icon = 'üì®';
                    type = 'result';
                    cssClass = 'result';
                }

                const el = document.createElement('div');
                el.className = `event ${cssClass}`;
                if (type === 'error') {
                    el.style.borderLeftColor = '#f87171';
                }

                el.innerHTML = `
                    <div class="event-header">
                        <div class="event-label">
                            <span class="event-icon">${icon}</span>
                            <span class="event-type">${type}</span>
                        </div>
                    </div>
                    <div class="event-content" style="white-space:pre-wrap;word-break:break-word;font-size:12px;">${escapeHtml(content)}</div>
                `;
                feed.appendChild(el);
                plainTextBuffer = [];
            }

            for (const line of lines) {
                // Try to parse as JSON event first
                let el = null;
                const trimmed = line.trim();

                if (trimmed.startsWith('{')) {
                    try {
                        const parsed = JSON.parse(trimmed);
                        // Check for wrapped format {ts, event} or raw format {type, message}
                        if (parsed.ts && parsed.event) {
                            // Wrapped format from WebSocket - flush buffer first
                            flushPlainTextBuffer();
                            el = renderEvent(parsed);
                        } else if (parsed.type && (parsed.type === 'user' || parsed.type === 'assistant' || parsed.type === 'system' || parsed.type === 'result')) {
                            // Raw Claude Code event format - flush buffer first
                            flushPlainTextBuffer();
                            el = renderEvent({ ts: Date.now(), event: parsed });
                        }
                        if (el) {
                            feed.appendChild(el);
                            continue;
                        }
                    } catch (e) {
                        // Not JSON, fall through to plain text handling
                    }
                }

                // Check for separator lines that indicate a new section
                if (/^={10,}$/.test(trimmed) || /^-{10,}$/.test(trimmed)) {
                    flushPlainTextBuffer();
                    continue;  // Skip the separator line itself
                }

                // Accumulate plain text
                plainTextBuffer.push(line);
            }

            // Flush any remaining plain text
            flushPlainTextBuffer();

            // Auto-scroll if enabled AND user is at bottom
            if (autoscroll && userAtBottom) {
                scrollToBottom();
            }

            // Trim old entries
            while (feed.children.length > MAX_EVENTS * 2) {
                feed.removeChild(feed.firstChild);
            }
        }

        function startTaskLogPolling() {
            if (taskLogInterval) return;
            fetchTaskLog();
            taskLogInterval = setInterval(fetchTaskLog, 1000);
        }

        function stopTaskLogPolling() {
            if (taskLogInterval) {
                clearInterval(taskLogInterval);
                taskLogInterval = null;
            }
        }

        function startTasksPolling() {
            if (tasksInterval) return;
            fetchTasks();
            tasksInterval = setInterval(fetchTasks, 30000);
        }

        function stopTasksPolling() {
            if (tasksInterval) {
                clearInterval(tasksInterval);
                tasksInterval = null;
            }
        }

        // ==================== Init ====================
        function init() {
            // Load saved settings
            loadSettings();
            renderFilters();
            renderChannelFilters();

            // Set initial autoscroll toggle state (both desktop and mobile)
            document.querySelectorAll('#autoscroll-toggle, #autoscroll-toggle-mobile').forEach(toggle => {
                toggle.classList.toggle('on', autoscroll);
            });

            const params = new URLSearchParams(location.search);
            const urlKey = params.get('key');

            if (urlKey) {
                authenticate(urlKey)
                    .then(() => { history.replaceState({}, '', '/'); showFeed(); connect(); })
                    .catch((e) => {
                        history.replaceState({}, '', '/');
                        showAuth();
                        document.getElementById('auth-error').textContent = e.message || 'Invalid code';
                    });
            } else if (getToken()) {
                // Check if we have passphrase for re-auth on token expiry
                if (!getPassphrase()) {
                    console.log('[Auth] Token exists but no passphrase - will need to re-enter on expiry');
                }
                showFeed();
                connect();
            } else if (getPassphrase()) {
                // No token but have passphrase - try to re-auth
                console.log('[Auth] No token but have passphrase, trying re-auth');
                tryReauthenticate().then(ok => {
                    if (ok) { showFeed(); connect(); }
                    else { showAuth(); }
                });
            } else {
                showAuth();
            }
        }

        init();

        // ==================== Marbles Physics ====================
        const MARBLES_VERSION = 'v45';
        const marblesCanvas = document.getElementById('marbles-canvas');
        const marblesCtx = marblesCanvas ? marblesCanvas.getContext('2d') : null;

        // Event type to marble color mapping (matches card colors)
        const marbleColors = {
            thinking: '#60a5fa',   // blue
            Read: '#a78bfa',       // purple
            Write: '#f472b6',      // pink
            Edit: '#fb923c',       // orange
            Bash: '#4ade80',       // green
            Grep: '#fbbf24',       // yellow
            Glob: '#fbbf24',       // yellow
            Task: '#22d3ee',       // cyan
            TodoWrite: '#a3e635',  // lime
            result: '#10b981',     // teal
            system: '#8b5cf6',     // purple
            WebSearch: '#f59e0b',  // amber
            WebFetch: '#f59e0b',   // amber
            AskUserQuestion: '#f59e0b', // amber
            NotebookEdit: '#f59e0b',    // amber
            default: '#f59e0b'     // amber for unknown tools
        };

        // Marbles state
        let marbles = [];
        let obstacles = [];
        // Fixed internal dimensions - canvas scales visually but physics stay constant
        const MARBLES_WIDTH = 450;
        const MARBLES_HEIGHT = 900;
        let marblesWidth = MARBLES_WIDTH;
        let marblesHeight = MARBLES_HEIGHT;
        let marblesAnimating = false;
        let lastSpawnTime = 0;
        let pendingSpawns = [];
        const SPAWN_DELAY = 125; // 0.125s minimum between spawns

        // Physics constants
        const GRAVITY = 0.3;
        const FRICTION = 0.98;
        const BOUNCE = 0.85;
        const MARBLE_BOUNCE = 0.85;  // Same as wall bounce
        const MARBLE_RADIUS = 10;
        const MAX_MARBLES = 1000;

        let hoveredMarble = null;
        let beadMarbles = new Map();  // beadId -> marble reference

        // Bead status colors
        const beadStatusColors = {
            'open': '#3b82f6',       // blue
            'in_progress': '#f59e0b', // amber/orange
            'closed': '#6b7280',     // gray
        };

        class Marble {
            constructor(x, y, type, summary, options = {}) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = Math.random() * 2;
                this.radius = options.radius || MARBLE_RADIUS;
                this.type = type;
                this.color = options.color || marbleColors[type] || marbleColors.default;
                this.summary = summary || type;
                this.saturation = 100;  // Starts fully saturated
                this.settled = false;
                this.settledTime = 0;
                this.slowFrames = 0;  // Count consecutive slow frames
                this.static = false;  // Fully frozen after 10s settled
                this.spawnTime = Date.now();
                this.beadId = options.beadId || null;  // For bead marbles
                this.beadStatus = options.beadStatus || null;
                this.eventData = options.eventData || null;  // Original event data for modal
            }

            getDisplayColor() {
                // Bead marbles use status color directly (no saturation fade)
                if (this.beadId) {
                    return beadStatusColors[this.beadStatus] || this.color;
                }
                // Regular marbles desaturate based on saturation level
                const desatAmount = (100 - this.saturation) / 100;
                return this.desaturate(this.color, desatAmount);
            }

            desaturate(hex, amount) {
                // Convert hex to RGB
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                // Convert to grayscale
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                // Blend toward gray
                const nr = Math.round(r + (gray - r) * amount);
                const ng = Math.round(g + (gray - g) * amount);
                const nb = Math.round(b + (gray - b) * amount);
                return `rgb(${nr}, ${ng}, ${nb})`;
            }

            update() {
                if (this.static) return;  // Completely frozen

                if (this.settled) {
                    this.settledTime++;
                    // Become static after 10 seconds (600 frames at 60fps)
                    if (this.settledTime > 600) {
                        this.static = true;
                    }
                    return;
                }

                // Apply gravity
                this.vy += GRAVITY;

                // Apply friction
                this.vx *= FRICTION;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Bounce off walls
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx *= -BOUNCE;
                }
                if (this.x + this.radius > marblesWidth) {
                    this.x = marblesWidth - this.radius;
                    this.vx *= -BOUNCE;
                }

                // Bounce off floor
                if (this.y + this.radius > marblesHeight) {
                    this.y = marblesHeight - this.radius;
                    this.vy *= -BOUNCE;
                }

                // Track slow movement - settle after 3 seconds of being slow in lower area
                if (Math.abs(this.vy) < 2 && Math.abs(this.vx) < 1.5 && this.y > marblesHeight * 0.6) {
                    this.slowFrames++;
                    if (this.slowFrames > 180) {  // 3 seconds at 60fps
                        this.settled = true;
                    }
                } else {
                    this.slowFrames = 0;  // Reset if moving fast
                }

                // Bounce off ceiling (soft)
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy *= -BOUNCE * 0.5;
                }

                // Collide with obstacles
                for (const obs of obstacles) {
                    this.resolveCollisionWithCircle(obs.x, obs.y, obs.radius);
                }
            }

            resolveCollisionWithCircle(ox, oy, oRadius) {
                const dx = this.x - ox;
                const dy = this.y - oy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = this.radius + oRadius;

                if (dist < minDist && dist > 0) {
                    // Normalize collision vector
                    const nx = dx / dist;
                    const ny = dy / dist;

                    // Move out of collision completely
                    this.x = ox + nx * minDist;
                    this.y = oy + ny * minDist;

                    // Reflect velocity
                    const dot = this.vx * nx + this.vy * ny;
                    if (dot < 0) {
                        this.vx -= 2 * dot * nx * BOUNCE;
                        this.vy -= 2 * dot * ny * BOUNCE;
                    }
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.getDisplayColor();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function initMarbles() {
            if (!marblesCanvas || !marblesCtx) return;

            initMarblesCanvas();
            createObstacles();
            // Don't auto-start - will start when marbles tab becomes active
            // startMarblesAnimation();
        }

        function initMarblesCanvas() {
            if (!marblesCanvas) return;
            // Set fixed internal dimensions
            marblesCanvas.width = MARBLES_WIDTH;
            marblesCanvas.height = MARBLES_HEIGHT;
            marblesWidth = MARBLES_WIDTH;
            marblesHeight = MARBLES_HEIGHT;
        }

        function createObstacles() {
            obstacles = [];
            if (marblesWidth === 0 || marblesHeight === 0) return;

            // Create pegs/obstacles at various positions
            const rows = 4;
            const pegsPerRow = 3;
            const startY = marblesHeight * 0.2;
            const endY = marblesHeight * 0.7;
            const rowSpacing = (endY - startY) / rows;

            for (let row = 0; row < rows; row++) {
                const y = startY + row * rowSpacing;
                const offset = row % 2 === 0 ? 0 : marblesWidth / (pegsPerRow * 2);

                for (let col = 0; col < pegsPerRow; col++) {
                    const x = (marblesWidth / (pegsPerRow + 1)) * (col + 1) + offset;
                    // Add some randomness to positions
                    const jitterX = (Math.random() - 0.5) * 20;
                    const jitterY = (Math.random() - 0.5) * 15;
                    obstacles.push({
                        x: x + jitterX,
                        y: y + jitterY,
                        radius: 15 + Math.random() * 10
                    });
                }
            }
        }

        function drawObstacles(ctx) {
            ctx.fillStyle = '#333';
            for (const obs of obstacles) {
                ctx.beginPath();
                ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function queueMarbleSpawn(eventType, summary, eventData) {
            // Cap pending queue at 50 to prevent runaway growth
            if (pendingSpawns.length >= 50) return;
            pendingSpawns.push({ type: eventType, summary: summary || eventType, eventData });
        }

        function processPendingSpawns() {
            const now = Date.now();
            if (pendingSpawns.length > 0 && now - lastSpawnTime >= SPAWN_DELAY) {
                const spawn = pendingSpawns.shift();
                spawnMarbleNow(spawn.type, spawn.summary, spawn.eventData);
                lastSpawnTime = now;
            }
        }

        function spawnMarbleNow(eventType, summary, eventData) {
            if (!marblesCanvas || marblesWidth === 0) return;

            // Don't spawn if at capacity
            if (marbles.length >= MAX_MARBLES) return;

            // Decrease saturation on all existing marbles, min 10%
            // 4.5% per spawn = fully faded after 20 new marbles
            for (const m of marbles) {
                if (m.saturation > 10) {
                    m.saturation = Math.max(10, m.saturation - 4.5);
                }
            }

            // Spawn from random position at top
            const x = Math.random() * (marblesWidth - MARBLE_RADIUS * 4) + MARBLE_RADIUS * 2;
            const y = MARBLE_RADIUS * 2;

            const marble = new Marble(x, y, eventType, summary, { eventData });
            marbles.push(marble);
        }

        function updateMarbles() {
            // Process pending spawns with delay
            processPendingSpawns();

            // Update each marble
            for (const marble of marbles) {
                marble.update();
            }

            // Marble-to-marble collisions - run multiple iterations for stability
            for (let iter = 0; iter < 3; iter++) {
                for (let i = 0; i < marbles.length; i++) {
                    for (let j = i + 1; j < marbles.length; j++) {
                        const m1 = marbles[i];
                        const m2 = marbles[j];

                        // Skip if both are static
                        if (m1.static && m2.static) continue;

                        const dx = m2.x - m1.x;
                        const dy = m2.y - m1.y;
                        const distSq = dx * dx + dy * dy;
                        const minDist = m1.radius + m2.radius;

                        if (distSq < minDist * minDist && distSq > 0) {
                            const dist = Math.sqrt(distSq);
                            // Normalize
                            const nx = dx / dist;
                            const ny = dy / dist;

                            // Determine which marbles can move
                            const m1Frozen = m1.static || m1.settled;
                            const m2Frozen = m2.static || m2.settled;

                            // Separate - only move non-frozen marbles
                            const overlap = minDist - dist;
                            if (m1Frozen && !m2Frozen) {
                                m2.x += nx * overlap;
                                m2.y += ny * overlap;
                            } else if (m2Frozen && !m1Frozen) {
                                m1.x -= nx * overlap;
                                m1.y -= ny * overlap;
                            } else if (!m1Frozen && !m2Frozen) {
                                const separateX = nx * overlap * 0.5;
                                const separateY = ny * overlap * 0.5;
                                m1.x -= separateX;
                                m1.y -= separateY;
                                m2.x += separateX;
                                m2.y += separateY;
                            }
                            // If both frozen, don't move either

                            // Clamp to bounds after separation
                            if (!m1Frozen) {
                                m1.x = Math.max(m1.radius, Math.min(marblesWidth - m1.radius, m1.x));
                                m1.y = Math.max(m1.radius, Math.min(marblesHeight - m1.radius, m1.y));
                            }
                            if (!m2Frozen) {
                                m2.x = Math.max(m2.radius, Math.min(marblesWidth - m2.radius, m2.x));
                                m2.y = Math.max(m2.radius, Math.min(marblesHeight - m2.radius, m2.y));
                            }

                            // Apply collision response based on frozen state
                            if (m1Frozen && m2Frozen) {
                                // Both frozen, no velocity change
                            } else if (m2Frozen) {
                                // m1 hitting frozen m2 - wall reflection
                                // Normal points from m1 to m2, dot > 0 means approaching
                                const dot = m1.vx * nx + m1.vy * ny;
                                if (dot > 0) {
                                    m1.vx -= 2 * dot * nx * MARBLE_BOUNCE;
                                    m1.vy -= 2 * dot * ny * MARBLE_BOUNCE;
                                }
                            } else if (m1Frozen) {
                                // m2 hitting frozen m1 - wall reflection
                                // Normal points from m1 to m2, so m2 approaching means dot < 0
                                const dot = m2.vx * nx + m2.vy * ny;
                                if (dot < 0) {
                                    m2.vx -= 2 * dot * nx * MARBLE_BOUNCE;
                                    m2.vy -= 2 * dot * ny * MARBLE_BOUNCE;
                                }
                            } else {
                                // Both moving - elastic collision between equal masses
                                const dvx = m1.vx - m2.vx;
                                const dvy = m1.vy - m2.vy;
                                const dvn = dvx * nx + dvy * ny;
                                if (dvn > 0) {
                                    const impulse = dvn * (1 + MARBLE_BOUNCE) * 0.5;
                                    m1.vx -= impulse * nx;
                                    m1.vy -= impulse * ny;
                                    m2.vx += impulse * nx;
                                    m2.vy += impulse * ny;
                                }
                            }
                        }
                    }
                }
            }

        }

        function drawMarbles(ctx) {
            // Clear canvas completely
            ctx.fillStyle = '#050508';
            ctx.fillRect(0, 0, marblesWidth, marblesHeight);

            // Draw version indicator
            ctx.fillStyle = '#333';
            ctx.font = '10px monospace';
            ctx.fillText(MARBLES_VERSION, marblesWidth - 25, 15);

            // Draw obstacles
            drawObstacles(ctx);

            // Draw marbles
            for (const marble of marbles) {
                marble.draw(ctx);
            }

            // Draw tooltip if hovering
            drawTooltip(ctx);
        }

        function marblesLoop() {
            if (!marblesAnimating) return;

            // Only run physics and draw when marbles tab is visible
            if (marblesTabActive) {
                updateCompactionShift(); // Animate compaction shift if active
                updateMarbles();
                drawMarbles(marblesCtx);
            }

            requestAnimationFrame(marblesLoop);
        }

        function startMarblesAnimation() {
            if (marblesAnimating) return;
            marblesAnimating = true;
            marblesLoop();
        }

        function stopMarblesAnimation() {
            marblesAnimating = false;
        }

        // ==================== Compaction Effect ====================
        // Animated shift state
        let compactionShiftRemaining = 0;
        let compactionTotalShift = 0; // Track total shift for bumper placement
        const COMPACTION_SHIFT_SPEED = 15; // pixels per frame
        const MIN_BUMPER_ROW_SPACING = 80; // Minimum vertical gap between bumper rows

        function triggerCompaction() {
            if (marbles.length < 4) return; // Need enough marbles to compact

            // Sort by Y position (highest Y = lowest on screen / bottom)
            const sorted = [...marbles].sort((a, b) => b.y - a.y);

            // Remove bottom 50%
            const removeCount = Math.floor(sorted.length / 2);
            const toRemove = new Set(sorted.slice(0, removeCount));
            marbles = marbles.filter(m => !toRemove.has(m));

            if (marbles.length === 0) return;

            // Find lowest remaining marble
            const lowestY = Math.max(...marbles.map(m => m.y + m.radius));

            // Calculate shift to move remaining marbles to bottom
            const targetBottomY = marblesHeight - 50; // 50px from canvas bottom
            const shiftAmount = targetBottomY - lowestY;

            if (shiftAmount > 0) {
                // Start animated shift
                compactionShiftRemaining = shiftAmount;
                compactionTotalShift = shiftAmount;
            } else {
                compactionTotalShift = 0;
            }

            // Boost saturation on remaining marbles (they're "fresh" after compaction)
            for (const m of marbles) {
                m.saturation = Math.min(100, m.saturation + 40);
                // Unsettle them so they can move again
                m.settled = false;
                m.static = false;
                m.settledTime = 0;
            }

            console.log(`Compaction: removed ${removeCount} marbles, ${marbles.length} remaining, shifting ${shiftAmount}px`);
        }

        // Called each frame to animate the compaction shift
        function updateCompactionShift() {
            if (compactionShiftRemaining <= 0) return;

            const step = Math.min(COMPACTION_SHIFT_SPEED, compactionShiftRemaining);
            compactionShiftRemaining -= step;

            // Shift all marbles down
            for (const m of marbles) {
                m.y += step;
            }

            // Shift all bumpers down too
            for (const obs of obstacles) {
                obs.y += step;
            }

            // When shift is complete, maybe add bumpers
            if (compactionShiftRemaining <= 0) {
                addUpperBumpers();
            }
        }

        function addUpperBumpers() {
            // Find the highest (lowest Y) existing obstacle
            const highestBumperY = obstacles.length > 0
                ? Math.min(...obstacles.map(o => o.y - o.radius))
                : marblesHeight;

            // Only add bumpers if there's enough headroom
            // Need at least MIN_BUMPER_ROW_SPACING * 2 for two rows with gaps
            const availableSpace = highestBumperY - 50; // Leave 50px margin at top

            if (availableSpace < MIN_BUMPER_ROW_SPACING) {
                console.log(`Not enough headroom for bumpers (${availableSpace}px available)`);
                return;
            }

            // Calculate how many rows we can fit
            const maxRows = Math.floor(availableSpace / MIN_BUMPER_ROW_SPACING);
            const rows = Math.min(2, maxRows); // Cap at 2 rows

            if (rows < 1) return;

            const pegsPerRow = 3;
            const startY = 50; // Start 50px from top
            const rowSpacing = Math.min(MIN_BUMPER_ROW_SPACING, availableSpace / (rows + 1));

            console.log(`Adding ${rows} bumper rows with ${rowSpacing}px spacing`);

            for (let row = 0; row < rows; row++) {
                const y = startY + row * rowSpacing;
                const offset = row % 2 === 0 ? 0 : marblesWidth / (pegsPerRow * 2);

                for (let col = 0; col < pegsPerRow; col++) {
                    const x = (marblesWidth / (pegsPerRow + 1)) * (col + 1) + offset;
                    const jitterX = (Math.random() - 0.5) * 20;
                    const jitterY = (Math.random() - 0.5) * 15;
                    obstacles.push({
                        x: x + jitterX,
                        y: y + jitterY,
                        radius: 15 + Math.random() * 10
                    });
                }
            }
        }

        // Test function to spawn multiple marbles quickly
        function spawnTestMarbles(count = 50) {
            const testTypes = ['thinking', 'Read', 'Write', 'Edit', 'Bash', 'Grep', 'Task', 'result', 'system'];
            const testSummaries = ['test.js', 'main.py', 'index.html', 'npm install', 'git status', 'analyzing...', 'searching...', 'done!'];

            let spawned = 0;
            const interval = setInterval(() => {
                if (spawned >= count) {
                    clearInterval(interval);
                    console.log(`Spawned ${count} test marbles`);
                    return;
                }

                const type = testTypes[Math.floor(Math.random() * testTypes.length)];
                const summary = testSummaries[Math.floor(Math.random() * testSummaries.length)];
                // Spawn directly, bypassing the rate-limited queue
                spawnMarbleNow(type, summary, null);
                spawned++;
            }, 100); // Spawn one every 100ms
        }

        // Hook into event system to spawn marbles
        const originalAddEvent = addEvent;
        addEvent = function(data) {
            const isNew = originalAddEvent(data);

            // Only spawn marble if this was a new event (not duplicate)
            if (!isNew) return;

            // Spawn marble for this event
            const event = data.event;
            if (!event) return;

            let eventType = null;
            let summary = null;

            if (event.type === 'assistant') {
                const blocks = event.message?.content || [];
                for (const block of blocks) {
                    if (block.type === 'text' && block.text) {
                        eventType = 'thinking';
                        // First 50 chars of thinking
                        summary = block.text.slice(0, 50).replace(/\n/g, ' ');
                        if (block.text.length > 50) summary += '...';
                    } else if (block.type === 'tool_use') {
                        eventType = block.name;
                        const input = block.input || {};
                        // Create summary based on tool type
                        if (block.name === 'Read' || block.name === 'Write' || block.name === 'Edit') {
                            const path = input.file_path || '';
                            summary = path.split('/').pop() || block.name;
                        } else if (block.name === 'Bash') {
                            const cmd = input.command || '';
                            summary = cmd.slice(0, 40);
                            if (cmd.length > 40) summary += '...';
                        } else if (block.name === 'Grep' || block.name === 'Glob') {
                            summary = input.pattern || block.name;
                        } else if (block.name === 'Task') {
                            summary = input.description || 'Task';
                        } else if (block.name === 'TodoWrite') {
                            const todos = input.todos || [];
                            const inProgress = todos.find(t => t.status === 'in_progress');
                            summary = inProgress ? inProgress.content.slice(0, 40) : 'Todos';
                        } else {
                            summary = block.name;
                        }
                    }
                }
            } else if (event.type === 'user') {
                const blocks = event.message?.content || [];
                for (const block of blocks) {
                    if (block.type === 'tool_result') {
                        eventType = 'result';
                        const resultStr = normalizeContent(block.content);
                        summary = resultStr.slice(0, 40).replace(/\n/g, ' ');
                        if (resultStr.length > 40) summary += '...';
                    }
                }
            } else if (event.type === 'system') {
                // Check for compaction events
                const subtype = (event.subtype || '').toLowerCase();
                if (subtype === 'compaction' || subtype === 'compact' ||
                    subtype === 'summarize' || subtype === 'context_compaction' ||
                    subtype.includes('compaction')) {
                    triggerCompaction();
                    // Still spawn a marble for the event
                }
                eventType = 'system';
                summary = event.subtype || 'system';
            }

            if (eventType) {
                queueMarbleSpawn(eventType, summary, data);
            }
        };

        // Mouse hover detection for marbles
        function setupMarbleHover() {
            if (!marblesCanvas) return;

            marblesCanvas.addEventListener('mousemove', (e) => {
                const rect = marblesCanvas.getBoundingClientRect();
                // Scale mouse coordinates to canvas internal size
                const scaleX = marblesCanvas.width / rect.width;
                const scaleY = marblesCanvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                // Find marble under cursor (check from top, most recent first)
                hoveredMarble = null;
                for (let i = marbles.length - 1; i >= 0; i--) {
                    const m = marbles[i];
                    const dx = x - m.x;
                    const dy = y - m.y;
                    if (dx * dx + dy * dy < m.radius * m.radius) {
                        hoveredMarble = m;
                        break;
                    }
                }
                marblesCanvas.style.cursor = hoveredMarble ? 'pointer' : 'default';
            });

            marblesCanvas.addEventListener('mouseleave', () => {
                hoveredMarble = null;
            });

            // Click handler for marbles
            marblesCanvas.addEventListener('click', (e) => {
                const rect = marblesCanvas.getBoundingClientRect();
                // Scale click coordinates to canvas internal size
                const scaleX = marblesCanvas.width / rect.width;
                const scaleY = marblesCanvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                // Find marble under cursor
                for (let i = marbles.length - 1; i >= 0; i--) {
                    const m = marbles[i];
                    const dx = x - m.x;
                    const dy = y - m.y;
                    if (dx * dx + dy * dy < m.radius * m.radius) {
                        if (m.beadId) {
                            // Bead marble - navigate to task view
                            viewTask(m.beadId, m.summary);
                        } else if (m.eventData) {
                            // Regular event marble - show event modal
                            showEventModal(m.eventData);
                        }
                        break;
                    }
                }
            });
        }

        // Draw tooltip for hovered marble
        function drawTooltip(ctx) {
            if (!hoveredMarble) return;

            const m = hoveredMarble;
            const text = m.summary;
            ctx.font = '12px monospace';
            const metrics = ctx.measureText(text);
            const padding = 6;
            const width = metrics.width + padding * 2;
            const height = 20;

            // Position tooltip above marble
            let tx = m.x - width / 2;
            let ty = m.y - m.radius - height - 5;

            // Keep on screen
            if (tx < 5) tx = 5;
            if (tx + width > marblesWidth - 5) tx = marblesWidth - width - 5;
            if (ty < 5) ty = m.y + m.radius + 5;

            // Draw background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(tx, ty, width, height);
            ctx.strokeStyle = m.color;
            ctx.lineWidth = 1;
            ctx.strokeRect(tx, ty, width, height);

            // Draw text
            ctx.fillStyle = '#fff';
            ctx.fillText(text, tx + padding, ty + 14);
        }

        // Initialize marbles when page loads
        setTimeout(() => {
            initMarbles();
            setupMarbleHover();
        }, 100);
    </script>
</body>
</html>
